# 松散分布式系统的Chubby 锁服务

## 摘要

本文主要介绍Chubby 锁服务，它旨在提供为松散分布式系统提供粗粒度锁和可靠存储（尽管容量不大）。Chubby 提供了如带有建议锁的分布式文件系统一样的接口，但设计要点是可用性和可靠性，以及追求高性能。很多实例已经运行了一年多，其中一些处理了上万客户端并发请求。本文阐述Chubby 的最初设计及预计使用场景，并与实际使用进行对比，并解释了如何调整原始设计以适应不同场景。

## 1 介绍

本文描述的*锁服务* 被称作Chubby。它被设计在被高速网络连接起来的大量廉价服务器组成的松散分布式系统中使用。例如，一个Chubby 实例（也称为Chubby cell）可能在由1Gbit/s 以太网连起来的上万台4C服务器集群中使用。大多数Chubby cell在单个数据中心或机房，然而我们确实有至少一个Chubby cell其副本相距千里之外。

锁服务的意图，是允许客户端们对行为进行同步，并对环境基本信息达成一致。首要目标是对于适量的大量客户端提供可靠性，可用性，以及场景可理解性；吞吐量和存储量是其次才考虑的。Chubby 的客户端接口类似一个简单的文件系统，提供全文件读写，附带建议锁以及诸如文件修改等事件的通知。

我们希望Chubby 帮助开发者解决系统中粗粒度的同步问题，特别是从一组对等server 中选出leader。例如，GFS[7] 使用Chubby 锁来任命GFS master，Bigtable[3] 对于Chubby 有多种使用方式：选举master，帮助master 发现它控制的server，允许client 发现master。另外，GFS 和Bigtable 都使用Chubby 对少量元数据进行存储；因此他们将Chubby 作为分布式数据结构的基础。有些服务使用锁来在多个server 之间分配任务（粗粒度的）。
 
在Chubby 被开发出来之前，谷歌内部的大多数分布式系统使用 **ad hoc** 方法选主（当重复执行没问题时），或者需要操作员人工干预（当正确性至关重要时）。早前的案例中，Chubby 节省了一些计算能力。后期的案例中，在不需要人工处理异常的系统中显著提高了可用性。

熟悉分布式计算的读者会将选主问题作为分布式共识问题的一个实例，并意识到我们需要一种异步通信的解决方案；
