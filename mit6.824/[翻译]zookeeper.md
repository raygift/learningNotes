# ZooKeeper: 针对大型网络系统的无等待共识算法

## 摘要
本文中，我们阐述了ZooKeeper，一个分布式应用的共识处理服务。作为要求苛刻的基础设置的一部分，ZooKeeper 旨在为客户端构建更复杂的共识提供简单和高性能的底层服务。包括了副本集中服务中的群发消息，共享注册器，分布式锁服务。ZK 暴露出来的接口有共享注册器所拥有的无等待（wait-free）优势，事件驱动机制类似分布式文件系统中的独立缓存一样提供了一个简单的，有效的共享服务。

ZK 接口实现了高性能服务。加上无等待的特性，ZooKeeper 为每个客户端提供了处理请求时FIFO 的保证，并保证了所有会改变ZK 状态的请求的线性化。这些设计使得 实现本地server 读取请求的高性能处理管道成为可能。我们展示了目标负载，读写绿从2:1 到100:1, ZK 每秒可以处理成百上千的交易。这样的性能变现让ZK 被广泛应用与客户端应用程序。

## 1 简介

大规模分布式应用需要不同的协调构成。#TODO

实现协调的一种方式是为每种不同的协调需求开发不同的协调服务。#TODO

当设计协调服务时，我们避免了在server 端实现特定的原型，而是选择了暴露一个API，使得应用开发者可以实现他们自己的原型。#TODO

当设计ZK 的API 时，我们移除了阻塞原型，比如锁。#TODO

尽管无等待的特性对于性能和容错很重要，但对于协调来说还不够。#TODO

ZK 服务由一组服务器构成，服务器使用了副本来达到高可用和高性能。#TODO

为了保证update 操作满足线性化，我们实现了一个基于leader 的原子官博机制，称为Zab[24]。#TODO

在客户端缓存数据是提高读取性能的重要手段。#TODO

本论文中我们讨论了ZooKeeper 的设计和实现思想。

总结一下，本论文我们做出的主要贡献是：

**协调内核(Coordination kernel)**：我们提出了一种无等待的协调服务，使用在分布式系统中是弱一致性保证的。特别的，我们阐述了*coordination kernel* 的设计和实现，并已经在很多底层应用中用来实现多样的协调技术。

**协调副本(Coordination recipes)**：我们展示了如何在构建更高级协调原型时使用ZooKeeper，即使是分布式系统中常见的阻塞和强一致性的协调原型。

**协调的经验(Experience with Coordination)**：我们分享了使用ZooKeeper 的方法，以及衡量性能的方法。

## 2 ZooKeeper 服务

客户端使用ZooKeeper 客户端的库，通过一个客户端API 向ZK 发送请求。

本章节中，我们首先提供了ZK 服务较高级别的视角。然后讨论了客户端与ZK 交互所使用的API。

**专业术语**. 本文中我们使用 client 来描述ZK 服务的一个用户，server 来描述提供ZK 服务的一个进程，用znode 来描述在ZK 数据中内存数据节点，ZK 数据用被称为 *data tree*的分级命名空间组织起来。我们还使用term 的更新和写入来表示任意修改了 data tree 状态的操作。当连接到ZK 时，client 建立一个 *session* ，并获得一个请求接收者的session handle。

### 2.1 服务概览

ZooKeeper 提供给它的客户端数据节点（znode）的集合概述，znode 根据分级命名空间组织起来。

client 可以创建两种类型的znode：

**定期（Regular）**: Client 通过明确的创建和删除来维护regular znodes；

**短期（Ephemeral）**: Client 创建 ephemeral znodes，且会明确的删除，或者当创建它们的session终止时（人为或由于异常），让系统自动删除这些znode。

另外，当创建一个新的znode时，client 可以设置一个 sequential 标志。

ZooKeeper 实现了watch，允许client 及时接收变化的通知，而不需要投票。

**数据模型(Data model)**. 
ZK 的数据模型本质是一个文件系统，带有简化的、只允许读写的API，或者说是一个有key分级的key/value 表。


与文件系统中的文件不同，znodes 不是被设计用来实现通用数据存储的。znodes 是client 应用的抽象映射，通常是为了达到协调目的的元数据。

尽管znodes 不是被用来存储通用数据的，ZK 还是允许client 存储一些分布式计算中可能被用作元数据或者配置信息的数据。

**Sessions**. 
一个client 连接到ZK 并开启一个session。Session 有一个被分配的超时时间。ZK 认为在session 超时时间内没有接收到任何信息的client 是发生了client 异常的。当client 明确关闭session handle 或者ZK 判断client 异常时，一个session 就结束了。通过session，client 获取到一个反映出client 操作执行后状态改变成功的信息。Session 允许client 透明的从ZK 集群的一个server 移到另一个server，由此持久化是跨ZK 节点的。


### 2.2 客户端API

下方展示了一些有关的ZK API，并讨论每个请求的场景。

**create(path, data, flags)**: 

delete(path, version):

exists(path, watch):

getData(path, watch):

setData(patch, data, version):

getChildren(path, watch):

sync(path):

所有方法都有同步和异步版本的API。当需要执行一个ZK 操作且没有其他并行任务时，程序会使用同步API，来调用ZK 并阻塞。然而异步API 允许程序并行执行多个ZK操作和其他任务。ZK client 保证了每个操作回调被有序的唤醒。

需要注意ZK 不使用handles 访问znodes。每个请求都不带有要操作的znode 的完整路径。这不仅简化了API（无需open() 或close() 方法），而且减少了server 需要维护的额外状态。

每种更新方法携带了一个版本号，用来实现条件更新。如果zone实际版本号与期望的版本号不相符，更新操作将由于 unexpected version 错误而失败。如果版本号是-1，表示不进行版本检查。

### 2.3 ZooKeeper 保证了啥

ZK 有两个基本的有序保证

**线性写入**：所有更新ZK 状态的请求都是可串行化；

**先进先出客户端顺序**：客户端发来的所有请求都是按照他们被客户端发出的顺序执行的

请注意我们定义的线性化与Herlihy[15] 的原始描述有区别，我们称为A-linearizability（异步线性化）。在Herlihy 原始定义中，客户端一次只能有一个请求（客户端是单线程的）。在我们的定义中，允许客户端并行发送多个操作，并且由此我们可以选择对于同一个客户端发出的突出的操作不指定特定顺序，或者保证FIFO 顺序。我们选择了后者作为ZK 的特性。注意到为线性化对象所持有的结果，同样被异步线性化对象所持有，因为满足异步线性化的系统同样满足线性化。由于只有更新请求是异步线性化的，ZK 进程从本地每个副本读取请求。这允许向系统中增加server 来达到服务线性扩展。

为了明白上述两个ZK 保证如何交互，考虑如下情景。由一堆进程构成的系统选举了一个leader 来向worker 进程发送命令。当新leader 开始掌管系统时，它必须改变大量配置参数，并在完成时通知其他进程。此时我们有两个重要需求：

- 在新leader 开始进行改变时，我们不希望其他进程开始使用新leader 正在改变的配置；
- 如果新leader 在完成配置更新之前挂了，我们不希望进程们使用只更新了一部分的配置。

注意到分布式锁，诸如Chubby 提出的锁，可以满足第一个诉求，但对于第二个是不充分的。使用ZK，新leader 可以指定ready znode 的一个路径，其他进程只有在这个路径下的znode 存在时才会使用其配置。新leader 通过删除 ready 来对配置进行更改，对多种配置的znodes 进行更新，随后创建 ready。所有这些变更可以是管道线性的，且可以异步执行已尽快更新配置的状态。尽管一个变更操作的延迟是2毫秒，如果逐个处理，一个新leader 将耗费10秒来更新5000个不同的znode；通过使用异步处理将花费少于1秒的时间。由于顺序的保证，如果一个进程发现了ready 的znode，它必须能够看到新leader 实施的所有配置变更。如果新leader 在ready znode 创建出来之前挂掉，其他进程可以判断配置没有被完成，就不会采用。

上述情景还存在一个问题：

